# 7. 정렬 알고리즘

## 1. 삽입 정렬

숫자를 적절한 위치에 삽입하는 것, 여기서 밑줄은 인덱스를 뜻하고 굵은 글씨는 정렬 완료 상태다.

맨 끝에 있는 숫자는 정렬이 끝난 것으로 간주한다.

|  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  9   |  3   |  2   |  6   |  1   |  8   |  0   |  7   |  4   |  5   |

|   0   |    1     |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
| :---: | :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| **9** | <u>3</u> |  2   |  6   |  1   |  8   |  0   |  7   |  4   |  5   |

숫자를 정렬이 끝난 숫자랑 비교한다. 9가 더 크므로 3을 앞으로 보낸다.

|   0   |   1   |    2     |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
| :---: | :---: | :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| **3** | **9** | <u>2</u> |  6   |  1   |  8   |  0   |  7   |  4   |  5   |

그 다음 숫자를 정렬 된 숫자들과 비교한다. 2는 9보다 작으므로 9 앞으로 가야한다.

9 앞의 숫자인 3과 2를 비교했을때 2는 3보다 작으므로 3 앞으로 간다.

|   0   |   1   |   2   |    3     |  4   |  5   |  6   |  7   |  8   |  9   |
| :---: | :---: | :---: | :------: | :--: | :--: | :--: | :--: | :--: | :--: |
| **2** | **3** | **9** | <u>6</u> |  1   |  8   |  0   |  7   |  4   |  5   |

그 다음 숫자와 정렬된 숫자들을 비교한다. 6은 9보다 작고 3보다 크므로 3과 9 사이에 넣는다.

같은 작업을 반복 진행한다.

|   0   |   1   |   2   |   3   |    4     |  5   |  6   |  7   |  8   |  9   |
| :---: | :---: | :---: | :---: | :------: | :--: | :--: | :--: | :--: | :--: |
| **2** | **3** | **6** | **9** | <u>1</u> |  8   |  0   |  7   |  4   |  5   |

|   0   |   1   |   2   |   3   |   4   |  5   |  6   |  7   |  8   |  9   |
| :---: | :---: | :---: | :---: | :---: | :--: | :--: | :--: | :--: | :--: |
| **1** | **2** | **3** | **6** | **9** |  8   |  0   |  7   |  4   |  5   |



|   0   |   1   |   2   |   3   |   4   |   5   |    6     |  7   |  8   |  9   |
| :---: | :---: | :---: | :---: | :---: | :---: | :------: | :--: | :--: | :--: |
| **1** | **2** | **3** | **6** | **8** | **9** | <u>0</u> |  7   |  4   |  5   |

|   0   |   1   |   2   |   3   |   4   |   5   |   6   |  7   |  8   |  9   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :--: | :--: | :--: |
| **0** | **1** | **2** | **3** | **6** | **8** | **9** |  7   |  4   |  5   |



|   0   |   1   |   2   |   3   |   4   |   5   |   6   |    7     |  8   |  9   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :------: | :--: | :--: |
| **0** | **1** | **2** | **3** | **6** | **8** | **9** | <u>7</u> |  4   |  5   |

|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |  8   |  9   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :--: | :--: |
| **0** | **1** | **2** | **3** | **6** | **7** | **8** | **9** |  4   |  5   |



|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |    8     |  9   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :------: | :--: |
| **0** | **1** | **2** | **3** | **6** | **7** | **8** | **9** | <u>4</u> |  5   |

|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |  9   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :--: |
| **0** | **1** | **2** | **3** | **4** | **6** | **7** | **8** | **9** |  5   |



|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |    9     |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :------: |
| **0** | **1** | **2** | **3** | **4** | **6** | **7** | **8** | **9** | <u>5</u> |

|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **0** | **1** | **2** | **3** | **4** | **5** | **6** | **7** | **8** | **9** |



삽입 정렬을 파이썬으로 구현해보자.

```python
>>> def insertion(list, low, high) :
...    for i in range(low+1, high+1) :
...        temp = list[i]
...        while list[i-1] > temp and i > low :
...            list[i] = list[i-1]
...            i -= 1
...        list[i] = temp
>>>     
>>> list = [5, 4, 3, 2, 1]
>>> insertion(list, 0, 4)
>>> print(list)
[1, 2, 3, 4, 5]
```



## 2. 선택 정렬

리스트에서 제일 작은 숫자를 찾는다.

|  0   |  1   |  2   |  3   |  4   |  5   |    6     |  7   |  8   |  9   |
| :--: | :--: | :--: | :--: | :--: | :--: | :------: | :--: | :--: | :--: |
|  9   |  3   |  2   |  6   |  1   |  8   | <u>0</u> |  7   |  4   |  5   |

찾은 숫자를 맨 앞 숫자와 바꾼다.

|   0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| **0** |  3   |  2   |  6   |  1   |  8   |  9   |  7   |  4   |  5   |

정렬이 안된 부분 중에서 제일 작은 숫자를 찾는다.

|   0   |  1   |  2   |  3   |    4     |  5   |  6   |  7   |  8   |  9   |
| :---: | :--: | :--: | :--: | :------: | :--: | :--: | :--: | :--: | :--: |
| **0** |  3   |  2   |  6   | <u>1</u> |  8   |  9   |  7   |  4   |  5   |

찾은 숫자를 두 번째 숫자와 바꾼다.

이렇게 끝까지 반복적으로 진행하면 된다.

|   0   |   1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
| :---: | :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| **0** | **1** |  2   |  6   |  3   |  8   |  9   |  7   |  4   |  5   |

...

|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **0** | **1** | **2** | **3** | **4** | **5** | **6** | **7** | **8** | **9** |

정렬 완료!



선택 정렬도 파이썬으로 작성해보자.

```python
>>> def selection(list, low, high) :
...    for i in range(low, high) ;
...    min = i
...    for j in range(i, high+1) :
...        if list[min] > list[j] :
...            min = j
...    list[min], list[i] = list[i], list[min]
>>>    
>>> list = [5, 4, 3, 2, 1]
>>> selection_sort(list, 0, 5)
>>> print(list)
[1, 2, 3, 4, 5]
```



## 3. 퀵 정렬

퀵 정렬은 평균적으로 nlogn의 시간복잡도를 가지지만 최악의 경우 N^2의 시간복잡도를 가진다.

키 값을 하나 정해 그 키값을 기준으로 숫자들을 나눠놓는 것이 핵심이다.



키 값을 하나 정한다.

|    0     |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
| :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| <u>5</u> |  9   |  3   |  2   |  6   |  1   |  8   |  0   |  7   |  4   |

키 값을 기준으로 작은 숫자는 왼쪽에 큰 숫자는 오른쪽에 놓는다. 여기선 위 아래로 함

| 0    | 1    | 2    | 3    | 4    |
| ---- | ---- | ---- | ---- | ---- |
| 3    | 2    | 1    | 0    | 4    |



| 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- |
| 9    | 6    | 8    | 7    |



키 값은 정렬이 완료 되었으니 나머지 위 아래에서 같은 작업을 반복한다.

| 0        | 1    | 2    | 3    | 4    |
| -------- | ---- | ---- | ---- | ---- |
| <u>3</u> | 2    | 1    | 0    | 4    |

작은 숫자는 왼족에 큰 숫자는 오른쪽에 놓는다.

...

|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **0** | **1** | **2** | **3** | **4** | **5** | **6** | **7** | **8** | **9** |

결국에 키값을 기준으로 작은 숫자는 왼쪽에, 큰 숫자는 오른쪽에 놓는 작업을 계속 반복하다 보면 정렬이 완료된다.



퀵 소트를 구현해보자.

```python
>>> def quick(list, low, high) :
...    if low >= high :
...        return
...    length = len(list)
...    pivot = list[low]
...    
...    j = low
...    for i in range(low+1, high+1) :
...	 	   if list[i] < pivot :
...            j += 1
...            list[i], list[j] = list[j], list[i] # 두 값을 swap
...			list[j], list[low] = list[low], list[j]
...    
...    quick(list, low, j-1)
...    quick(list, j+1, high)
>>> 
>>> list = [5, 3, 9, 8, 1]
>>> quick(list, 0, 4)
>>> print(list)
[1, 3, 5, 8, 9]
```





## 4. 병합 정렬

병합 정렬은 최선, 평균, 최악 모두 nlogn의 시간복잡도를 가진다.

먼저 수열을 반으로 나눈다.

|  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  5   |  9   |  3   |  2   |  6   |  1   |  8   |  0   |  7   |  4   |

여기서 반이면 5, 9, 3, 2, 6 / 1, 8, 0, 7, 4 이렇게 나눠진다.

이것을 또 반으로 나눈다(5, 9, 3 / 2, 6 / 1, 8, 0 / 7, 4)

이것을 또 반으로 나눈다(5, 9, / 3 / 2 / 6 / 1, 8 / 0 / 7 / 4)

이것을 또 반으로 나눈다(5 / 9 / 3 / 2 / 6 / 1 / 8 / 0 / 7 / 4)

나눠진 수열을 병합하기 시작한다. ( 5, 9 / 3 / 2, 6 / 1, 8 / 0 / 7 , 4)

나눠진 수열을 다시 병합한다.( 5, 9 / 3 / 2, 6 / 1, 8 / 0 / 4, 7)

나눠진 수열을 다시 병합한다.( 3, 5, 9 / 2, 6 / 0, 1, 8 / 4, 7)

나눠진 수열을 다시 병합한다.( 2, 3, 5, 6, 9 / 0, 1, 4  7, 8)

나눠진 수열을 다시 병합한다.( 0, 1, 2, 3, 4, 5 ,6 ,7 ,8 ,9)

병합이 완료되면 정렬이 완료된다.



각 수열의 첫 번째 숫자를 비교해서 작은 것을 쌓으면 그것이 오름차순, 큰 것을 먼저 쌓으면 내림차 순이 된다.



```python
>>> def merge_sort(list) :
...    if (len(list) <= 1) :
...        return
...    mid = len(list) // 2
...    left = merge_sort(a[:mid])
...    right = merge_sort(a[mid:])
...    return merge(left, right)
>>>
>>> def merge(left, right) :
...    result = []
...    while len(left) > 0 or len(right) > 0 :
...        if len(left) > 0 and len(right) > 0 :
...            if left[0] <= right[0] :
...                result.append(left[0])
...                left = left[1:]
...            else :
...                result.append(right[0])
...                right = right[1:]
...        elif len(left) > 0 :
...            result.append(left[0])
...            left = left[1:]
...        elif len(right) > 0 :
...            result.append(right[0])
...            right = right[1:]
...    return result
>>>
>>> list = [6, 5, 3, 1, 8, 7, 2, 4]
>>> print(merge(list))
[1, 2, 3, 4, 5, 6, 7, 8]
```

left: [6] / right: [5]

merge: [5, 6]



left: [3] / right: [1]

merge: [1, 3]



left: [5, 6] / right: [1, 3]

merge: [1, 3, 5, 6]



left: [8] / right: [7]

merge: [7, 8]



left: [2] / right: [4]

merge: [2, 4]



left: [7, 8] / right: [2, 4]

merge: [2, 4, 7, 8]



left: [1, 3, 5, 6] / right: [2, 4, 7, 8]

merge: [1, 2, 3, 4, 5, 6, 7, 8]

이와 같은 순서로 진행된다.